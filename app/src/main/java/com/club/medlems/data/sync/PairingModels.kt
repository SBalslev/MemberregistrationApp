package com.club.medlems.data.sync

import kotlinx.datetime.Instant
import kotlinx.serialization.Serializable

/**
 * Data encoded in the QR code for device pairing.
 * Generated by laptop, scanned by tablets.
 *
 * @see [design.md FR-10.4] - Pairing QR code contents
 * @see [design.md FR-22] - Device Pairing Ceremony Flow
 */
@Serializable
data class PairingQrCode(
    /** JWT trust token for authentication after pairing */
    val trustToken: String,
    
    /** Unique identifier for this sync network */
    val networkId: String,
    
    /** HTTP endpoint URL of the device generating the QR code */
    val endpoint: String,
    
    /** Device type expected to scan this QR code */
    val expectedDeviceType: DeviceType,
    
    /** Friendly name assigned to the device during pairing setup */
    val deviceName: String,
    
    /** Timestamp when this QR code was generated */
    val generatedAtUtc: Instant,
    
    /** Timestamp when this QR code expires (5 minutes after generation) */
    val expiresAtUtc: Instant,
    
    /** Schema version for compatibility check */
    val schemaVersion: String = SyncSchemaVersion.version
) {
    companion object {
        /** QR code validity duration in minutes */
        const val VALIDITY_MINUTES = 5L
        
        /** Prefix for QR code data to identify as pairing code */
        const val QR_PREFIX = "MEDLEMS_PAIR:"
    }
    
    /**
     * Check if this QR code has expired.
     */
    fun isExpired(currentTime: Instant): Boolean {
        return currentTime > expiresAtUtc
    }
    
    /**
     * Encode to string for QR code generation.
     */
    fun toQrString(): String {
        return QR_PREFIX + SyncJson.json.encodeToString(serializer(), this)
    }
}

/**
 * Parse a QR code string to PairingQrCode.
 * Returns null if the string is not a valid pairing QR code.
 */
fun parsePairingQrCode(qrString: String): PairingQrCode? {
    if (!qrString.startsWith(PairingQrCode.QR_PREFIX)) {
        return null
    }
    return try {
        val jsonPart = qrString.removePrefix(PairingQrCode.QR_PREFIX)
        SyncJson.json.decodeFromString(PairingQrCode.serializer(), jsonPart)
    } catch (e: Exception) {
        null
    }
}

/**
 * Request sent by tablet to laptop during pairing handshake.
 *
 * @see [design.md FR-18.2] - POST /api/pair endpoint
 */
@Serializable
data class PairingRequest(
    /** Trust token from QR code */
    val trustToken: String,
    
    /** New device information */
    val device: DeviceInfo,
    
    /** Schema version of the new device */
    val schemaVersion: String = SyncSchemaVersion.version
)

/**
 * Response from laptop after successful pairing.
 */
@Serializable
data class PairingResponse(
    /** Whether pairing was successful */
    val success: Boolean,
    
    /** Error message if pairing failed */
    val errorMessage: String? = null,
    
    /** JWT token for future sync authentication (if successful) */
    val authToken: String? = null,
    
    /** Network ID for this sync network */
    val networkId: String? = null,
    
    /** List of all currently trusted devices in the network */
    val trustedDevices: List<DeviceInfo> = emptyList(),
    
    /** Timestamp of this response */
    val timestamp: Instant
) {
    companion object {
        fun success(
            authToken: String,
            networkId: String,
            trustedDevices: List<DeviceInfo>,
            timestamp: Instant
        ) = PairingResponse(
            success = true,
            authToken = authToken,
            networkId = networkId,
            trustedDevices = trustedDevices,
            timestamp = timestamp
        )
        
        fun failure(errorMessage: String, timestamp: Instant) = PairingResponse(
            success = false,
            errorMessage = errorMessage,
            timestamp = timestamp
        )
    }
}

/**
 * Pairing failure reasons.
 */
enum class PairingError {
    /** QR code has expired */
    QR_EXPIRED,
    
    /** Trust token is invalid */
    INVALID_TOKEN,
    
    /** Schema versions are incompatible */
    SCHEMA_INCOMPATIBLE,
    
    /** Device type doesn't match expected */
    WRONG_DEVICE_TYPE,
    
    /** Connection timeout (30 seconds) */
    CONNECTION_TIMEOUT,
    
    /** Network error */
    NETWORK_ERROR,
    
    /** Unknown error */
    UNKNOWN
}
